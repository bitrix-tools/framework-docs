---
title: Кеширование
---

При больших объемах данных в базе могут возникать проблемы с производительностью. Основные причины:

1. **Конфликт запросов**. Одновременные запросы к базе данных могут конфликтовать друг с другом, создавая нагрузку на сервер.

2. **Очередь запросов.** Даже быстрые запросы могут накапливаться, образуя очередь и замедляя работу системы.

3. **Тяжелые запросы**. Медленные и частые запросы увеличивают нагрузку на сервер.

Кеширование помогает ускорить работу сайта и снизить нагрузку на базу данных. При правильно настроенном кешировании сайт использует сохраненные данные вместо того, чтобы заново обращаться к базе. Например, интернет-магазин может кешировать информацию о товарах.

## Класс для кеширования

[Cache](https://docs.1c-bitrix.ru/api/classes/Bitrix-Main-Data-Cache.html) -- основной класс для кеширования PHP-переменных и HTML-результатов.

### Основные методы класса

-  `createInstance()` -- создает экземпляр класса.

-  `initCache($time, $id, $dir)` -- проверяет наличие кеша:

   -  `$time` -- время жизни кеша в секундах,

   -  `$id` -- уникальный идентификатор кеша,

   -  `$dir` -- каталог хранения, необязательный параметр.

-  `getVars()` -- получает данные из кеша.

-  `startDataCache()` -- начинает создание нового кеша.

-  `endDataCache($data)` -- сохраняет данные в кеш.

-  `abortDataCache()` -- отменяет создание кеша. Применяется в случае ошибок или если данные недействительны.

## Примеры работы

Получить экземпляр кеша:

```php
// Получить экземпляр кеша через статический метод Cache::createInstance()
$cache = Bitrix\Main\Data\Cache::createInstance();

// Получить экземпляр кеша через объект приложения
$cache = Bitrix\Main\Application::getInstance()->getCache();
```

Проверить наличие кеша:

```php
// Проверяем наличие кеша
if ($cache->initCache(3600, 'cache_key'))
{
	// Получаем данные из кеша
    $data = $cache->getVars(); 
}
elseif ($cache->startDataCache())
{
	// Если кеша нет, получаем данные из базы
    $data = getDataFromDatabase();

	// Сохраняем результаты в кеш
    $cache->endDataCache($data);
}
```

Инициализировать кеш с дополнительными параметрами:

```php
// Инициализация кеша с дополнительными параметрами
if ($cache->initCache(
	$cacheTime, // Время жизни кеша в секундах
	$cacheId, // Уникальный идентификатор кеша
	$cacheDir // Путь к подкаталогу в кеше
))
{
	$result = $cache->getVars();
}
elseif ($cache->startDataCache())
{
	$result = array();
	// Если данные недействительны, отменяем кеширование
	if ($isInvalid)
	{
		$cache->abortDataCache();
	}
	// Сохраняем валидные данные
	$cache->endDataCache($result);
} 
```

Пример с кешированием буфера вывода.

```php
$cache = Bitrix\Main\Data\Cache::createInstance();

// Если есть закешированные данные, они выведутся в буфер в методе Cache::startDataCache
if ($cache->startDataCache(3600, 'xxxx'))
{
	echo 'Какой-нибудь HTML';
	
	$cache->endDataCache();
}
```

## Технологии кеширования

Bitrix Framework поддерживает несколько технологий кеширования:

1. Неуправляемое

2. Управляемое

3. Композитный сайт

4. Автокеширование компонентов

Для максимальной эффективности можно совмещать разные технологии. Каждый компонент сайта можно кешировать отдельно, выбирая подходящий метод для конкретной задачи.

### Неуправляемое кеширование

Кеширование называется неуправляемым, потому что кеш не перестраивается автоматически после модификации исходных данных и действует в течение указанного времени после создания.

Неуправляемое кеширование сохраняет результаты работы ресурсоемких частей страниц в файлы. По умолчанию используется папка `/bitrix/cache/`, но можно задать любую другую директорию. Кеш действует определенное время и не обновляется автоматически при изменении данных.

Как работает:

1. Система сохраняет результат выполнения кода в файл.

2. При следующем запросе вместо выполнения кода отдает сохраненный файл.

3. Файл хранится указанное время, после чего удаляется.

Пример использования неуправляемого кеширования:

```php
use Bitrix\Main\Application;

$cache = Application::getInstance()->getCache();

// Проверяем наличие кеша
if ($cache->initCache(3600, 'cache_key'))
{
	// Получаем данные из кеша
    $data = $cache->getVars(); 
}
elseif ($cache->startDataCache())
{
	// Если кеша нет, получаем данные из базы
    $data = getDataFromDatabase();

	// Сохраняем результаты в кеш
    $cache->endDataCache($data);
}
```

### Управляемое кеширование

Управляемое кеширование автоматически обновляет кеш при изменении данных. Кеш хранится в папке `/bitrix/managed_cache/`.

Преимущества:

-  Мгновенное обновление контента на сайте.

-  Поддержка различных хранилищ: Redis, Memcached, APC, XCache, файлы.

Как включить:

1. Войдите в административный раздел сайта.

2. Перейдите в *Настройки > Настройки продукта > Автокеширование.*

3. Включите управляемый кеш.

Для часто обновляемых данных управляемое кеширование не подходит. В таких случаях лучше использовать неуправляемое кеширование.

{% note warning "" %}

Не все компоненты поддерживают управляемое кеширование. Проверяйте поддержку в настройках компонента.

{% endnote %}

Пример использования управляемого кеширования:

```php
use Bitrix\Main\Application;

$managedCache = Application::getInstance()->getManagedCache();
$cacheKey = 'key';

// Проверяем наличие кеша с помощью read
if ($managedCache->read(3600, $cacheKey))
{
    // Получаем данные из кеша с помощью get
	$data = $managedCache->get('key-of-value');
}
else
{
    // Если кеша нет, загружаем данные и сохраняем их в кеш
	$data = loadDataFromAnywhere();
	$managedCache->set('key-of-value', $data);
}
```

Пример работы с управляемым кешем через специальные методы:

```php
use Bitrix\Main\Application;

$managedCache = Application::getInstance()->getManagedCache();
$cacheKey = 'key';

// если нужно просто получить данные
$vars = $managedCache->getImmediate(3600, $cacheKey);
if ($vars === false)
{
	$vars = loadDataFromAnywhere();
	$managedCache->setImmediate($cacheKey, $vars);
}
```

Управляемое кеширование связано с ORM и базой данных.

1. Укажите таблицу БД в методе третьим параметром.

2. Кеш автоматически сбросится при обновлении данных в этой таблице через ORM.

```php
use Bitrix\Main\Application;

$managedCache = Application::getInstance()->getManagedCache();
$cacheKey = 'key';

// Проверяем наличие кеша с помощью read
if ($managedCache->read(3600, $cacheKey, 'b_user'))
{
	// ...
}
```

Сбросить кеш через таблицу ORM:

```php
\Bitrix\Main\UserTable::cleanCache();
```

### Композитный сайт

Технология Композитный сайт делит страницу на статичные и динамические части. При первом посещении:

1. создается кеш статичной части,

2. добавляется JavaScript для загрузки динамического контента.

При повторном посещении:

1. отдается готовый статичный кеш,

2. загружается только динамический контент.

Подробнее о технологии -- в статье [Композитный сайт](./composite-site).

### Автокеширование компонентов

Автокеширование автоматически обновляет данные компонентов согласно их настройкам. Это помогает ускорить работу сайта при высокой нагрузке.

Как включить:

1. Откройте административную панель.

2. Перейдите в *Настройки > Настройки продукта > Автокеширование.*

3. Нажмите Включить автокеширование.

![](./caching.png){width=1261px height=757px}

Результат: компоненты с режимом Авто + Управляемое кеширование начинают работать без запросов к базе данных, используя созданный кеш.

## Конфигурация кеша

Настройки кеширования хранятся в файле `/bitrix/.settings.php` в секции `cache`.

### Параметр type

Параметр `type` определяет механизм кеширования.

-  **redis** -- использует Redis для хранения кеша. Требует установленного PHP-расширения `redis`.

-  **memcache** -- использует Memcached для хранения кеша. Требует установленного PHP-расширения `memcached`.

-  **apc** -- использует APC или APCu для хранения кеша. Требует установленного PHP-расширения `apcu`.

-  **xcache** -- использует XCache для хранения кеша. Требует установленного PHP-расширения `xcache`.

-  **files** -- хранит кеш в файлах на диске.

-  **none** -- отключает кеширование.

В параметре `type` указывается массив с настройками.

-  `class_name` -- класс, реализующий интерфейс ICacheEngine. Например, `\Bitrix\Main\Data\CacheEngineRedis`.

-  `required_file` -- путь к файлу с классом относительно папки `/bitrix/` или `/local/`. Не обязательный.

-  `required_remote_file`  -- абсолютный путь к файлу с классом. Не обязательный.

-  `extension` -- Название PHP-расширения, которое должно быть установлено для корректной работы. Например, `'extension' => 'redis'`.

### Параметр cache_flags

Параметр `cache_flags` управляет правилами кеширования для разных таблиц.

Пример для таблицы `b_group`:

```php
'cache_flags'=>   array(
      'value'=> array(
         "b_group_max_ttl" => 200,
         "b_group_min_ttl" => 100,
      )
   ),
```

-  `b_group_max_ttl` -- устанавливает максимальное время жизни кеша. Например, значение `86400` означает 1 день. Значение `0` полностью отключает кеширование для этой таблицы.

-  `b_group_min_ttl` устанавливает минимальное время жизни кеша. Если код пытается установить меньший срок, система будет использовать это значение.

### Параметр sid

SID (Site ID) нужен для уникальной идентификации кеша каждого сайта. Формируется так:

```php
$_SERVER["DOCUMENT_ROOT"] . "#01"
```

-  `$_SERVER["DOCUMENT_ROOT"]` -- путь к корневой директории сайта.

-  `#01` -- уникальный суффикс для разделения сайтов.

Примеры:

-  `/var/www/html/#01` -- для одного сайта.

-  `/var/www/html/#ru` и `/var/www/html/#en` -- для разных языков.

-  `/var/www/html/#example.com` и `/var/www/html/#blog.com` -- для разных доменов.

Неправильная конфигурация `SID` может привести к конфликтам кеша между сайтами.

{% note warning "" %}

При изменении формата SID нужно очистить старый кеш, так как система не сможет его использовать.

{% endnote %}

### Дополнительные параметры Redis и Memcache

Для механизмов кеширования Redis и Memcache нужно указать массив с адресом и портом сервера. Название параметра соответствует названию механизма. Например, для Redis:

```php
'redis' => array(
	'host' => '127.0.0.1', // Адрес сервера Redis
	'port' => '6379', // Порт сервера Redis
),
```

### Примеры настроек

Ниже приведены примеры настроек для каждого механизма кеширования.

#### Redis

```php
'cache' => array('value' => array(
          'type' => array(
              'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineRedis', // Класс для работы с Redis
              'extension' => 'redis' // Требуется расширение PHP redis
          ),
          'redis' => array(
              'host' => '127.0.0.1', // Адрес сервера Redis
              'port' => '6379', // Порт сервера Redis
          ),
          'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
)),
      ),
  ),
```

#### Memcache

```php
'cache' => array(
    'value' => array(
        'type' => array(
            'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineMemcache', // Класс для работы с Memcache
            'extension' => 'memcached' // Требуется расширение PHP memcached
        ),
        'memcache' => array(
            'host' => '127.0.0.1', // Адрес сервера Memcache
            'port' => '11211', // Порт сервера Memcache
        ),
        'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
    ),
),
```

Настройки memcache могут задаваться так же в файле `/bitrix/.settings_extra.php`.

```php
<?php
return array (
    'cache' => array(
        'value' => array (
            'type' => 'memcache',
            'memcache' => array(
                'host' => 'unix:///tmp/memcached.sock', // Сокет Unix для подключения к Memcache
                'port' => '0' // Порт не используется при работе через сокет
            ),
            'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
        ),
    ),
);
?>
```

Файл `.settings.php` содержит статические настройки с API, а `.settings_extra.php` позволяет динамически изменять параметры без API.

#### Apc

```php
'cache' => array(
    'value' => array(
        'type' => array(
            'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineApc', // Класс для работы с APC
            'extension' => 'apcu' // Требуется расширение PHP apcu
        ),
        'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
    ),
),
```

#### XCache

```php
'cache' => array(
    'value' => array(
        'type' => array(
            'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineXCache', // Класс для работы с XCache
            'extension' => 'xcache' // Требуется расширение PHP xcache
        ),
        'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
    ),
),
```

#### Files

```php
'cache' => array(
    'value' => array(
        'type' => array(
            'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineFiles', // Класс для работы с файловым кешированием
        ),
        'root_directory' => '/user_cache_dir/', // Директория для хранения файлов кеша
        'sid' => $_SERVER["DOCUMENT_ROOT"]."#01" // Уникальный идентификатор для разделения кеша между сайтами
    ),
)
```

С версии главного модуля 24.100.0, можно использовать произвольную директорию для файлового кеширования через параметр `root_directory`. По умолчанию используется `/bitrix/cache/`.

## Блокирующий режим кеширования

{% note info "" %}

Блокирующий режим доступен с версии 24.0.0 главного модуля и включен по умолчанию для всех компонентов.

{% endnote %}

Как работает:

1. Первый поток создает новый кеш.

2. Остальные потоки используют старый кеш до готовности нового.

3. Если старый кеш отсутствует, каждый поток генерирует данные самостоятельно.

### Условия применения

-  Кеш истек, но прошло не больше заданного времени.

-  Кеш удален, но прошло не больше 60 секунд. Время можно настроить.

### Пример кода

```php
// Создаем экземпляр кеша с поддержкой старых значений
$cache = Bitrix\Main\Data\Cache::createInstance(['actual_data' => false]);

// Удаляем кеш по ключу
$cache->clean($key, $dir);
```

### Преимущества блокирующего режима

-  Стабильное время генерации страниц

-  Снижение количества ошибок при высокой нагрузке

### Как включить блокирующий режим в Memcache

Memcache -- это система кеширования в памяти. Чтобы использовать блокирующий режим, добавьте следующие параметры в файл конфигурации:

```php
'cache' => [
    'value' => [
        'type' => [
            'class_name' => '\\Bitrix\\Main\\Data\\CacheEngineMemcache',
            'extension' => 'memcache',
        ],
        'memcache' => ['host' => '127.0.0.1', 'port' => '11211'],
        'use_lock' => true, // Включаем блокирующий режим
        'sid' => 'bxMemcache',
    ],
],
```

### Когда используется обычный механизм кеширования

Система переключается на стандартный механизм в случаях:

1. Кеш создан или очищен без параметра `['actual_data' => false]`.

2. Кеш истек больше, чем на заданное время.

3. Кеш очищен по тегу, папке или ключу более 60 секунд назад.

## Тегированный кеш

Главный модуль поддерживает тегированный кеш (Сache Dependencies).

1. Данные отмечаются тегами.

2. Если данные изменились, система находит кеш с этими тегами и очищает его.

### Особенности тегирования

-  Теги можно вкладывать друг в друга.

-  Теги из вложенных блоков применяются к родительским.

-  Дубликаты тегов автоматически удаляются.

### Где использовать

Тегированный кеш подходит:

-  для данных, которые редко обновляются,

-  если нужно мгновенное обновление кеша при изменениях.

Не используйте его для данных, которые часто меняются, или для сложных запросов с высокой нагрузкой.

### Основной класс

Класс `Bitrix\Main\Data\TaggedCache` работает с тегами.

### Пример тегированного кеша

```php
use Bitrix\Main\Application;

$cache = Application::getInstance()->getCache();
$cacheDir = 'my_cache_dir';
$taggedCache = Application::getInstance()->getTaggedCache();

// Проверяем наличие кеша
if ($cache->initCache(3600, 'cache_key', $cacheDir))
{
	// Получаем данные из кеша
	$data = $cache->getVars(); 
}
elseif ($cache->startDataCache())
{	
	// Если кеша нет, получаем данные из базы
	$data = getDataFromDatabase();
	
	// Помечаем кеш тегом
	$taggedCache->startTagCache($cacheDir);
	$taggedCache->registerTag('my_tag');
	$taggedCache->endTagCache();

	// Сохраняем результаты в кеш
	$cache->endDataCache($data);
}
```

Сбросьте тег, чтобы сбросить все записи кеша в директории `my_cache_dir`.

```php
use Bitrix\Main\Application;

Application::getInstance()->getTaggedCache()->clearByTag('my_tag');
```

## Обновление кеша компонентов

Поведение компонентов при обновлении кеша зависит от их настроек:

-  **Авто + Управляемое.** Система автоматически обновляет кеш по истечении заданного времени или при изменении данных.

-  **Кешировать**. Система обновляет кеш только по истечении указанного времени.

-  **Не кешировать**. Компоненты работают без кеширования.

### Как обновить кеш вручную

1. **В панели инструментов.** Нажмите кнопку Сбросить кеш на нужной странице сайта.

   ![](./caching-2.png){width=818px height=319px}

   {% note warning "" %}

   Если компонент учитывает права доступа, кеш хранится отдельно для каждой группы пользователей. Сброс кеша затронет только те группы, к которым принадлежит текущий пользователь.

   {% endnote %}

2. **В режиме правки сайта.** Включите режим правки сайта. Используйте кнопки очистки кеша в панелях отдельных компонентов, чтобы целенаправленно обновлять конкретные части страницы.

   ![](./caching-3.png){width=696px height=247px}

## Очистка файлов кеша

Чтобы очистить кеш через административную панель:

1. перейдите в *Настройки > Настройки продукта > Автокеширование,*

2. выберите вкладку Очистка файлов кеша.

### Варианты очистки

-  Только устаревшие -- удаляет файлы, срок действия которых истек.

-  Все -- полная очистка кеша.

-  Меню -- очищает кеш меню. Используется при проверке прав доступа к пунктам меню.

-  Весь управляемый -- удаляет содержимое директории `/bitrix/managed_cache/`.

   {% note warning "" %}

   Не рекомендуется ручное удаление файлов из этой директории

   {% endnote %}

-  Все страницы HTML-кеша -- удаляет сохраненные версии страниц.

-  Сайты24 -- удаляет кеш лендингов.

### Что происходит после очистки

-  Отображаемые данные обновляются до актуального состояния.

-  Новые файлы кеша создаются автоматически при обращении к страницам.

### Решение проблемы роста папки /bitrix/cache/

Файлы неуправляемого кеширования могут создаваться с неправильными правами доступа, что мешает их удалению. Это приводит к увеличению размера папки `/bitrix/cache/`.

Решение:

1. Откройте файл /bitrix/php_interface/dbconn.php.

2. Добавьте строки:

   ```php
   umask(000);
   @umask(~BX_DIR_PERMISSIONS);
   ```

3. Сохраните изменения.

{% note info "" %}

Права на файлы обычно определяются константами `BX_FILE_PERMISSIONS` и `BX_DIR_PERMISSIONS` в файле dbconn.php, но часто применяется маска сервера. Эти изменения помогут избежать проблем с правами доступа.

{% endnote %}
